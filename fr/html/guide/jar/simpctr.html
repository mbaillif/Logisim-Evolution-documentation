<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html lang="fr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="created" content="2023-08-10T26:35:22.126000000">
    <meta name="changed" content="2023-08-10T26:35:22.126000000">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="Content-Language" content="fr">
    <title>
       Compteur de codes Gray simple
    </title>
    <link rel="stylesheet" type="text/css" href="../../style.css">
  </head>
  <body>
    <div class=codediv>
      <h1>
        Compteur de codes Gray simple
      </h1>
      <p>
       Souvent, nous voulons des composants qui ne sont pas exclusivement de nature combinatoire - c'est-à-dire que nous voulons que le composant ait une certaine mémoire. La définition de ces composants comporte une subtilité importante : Vous ne pouvez pas faire en sorte que le composant lui-même stocke l'état, parce qu'un composant individuel peut apparaître plusieurs fois dans le même circuit. Il ne peut pas apparaître plusieurs fois directement dans un circuit, mais il peut apparaître plusieurs fois s'il apparaît dans un sous-circuit qui est utilisé plusieurs fois.
      </p>
      <p>
        La solution consiste à créer une nouvelle classe pour représenter l'état actuel de l'objet, et d'en associer des instances au composant par l'intermédiaire de l'état du circuit parent.       
		The solution is to create a new class for representing the object's current state, and to associate instances of this with the component through the parent circuit's state. Dans cet exemple, qui met en œuvre un compteur de code Gray 4 bits déclenché par front, nous définissons une classe <code>CounterData</code> pour représenter l'état du compteur, en plus de la sous-classe <code>InstanceFactory</code>, comme illustré précédemment. L'objet <code>CounterData</code> mémorise à la fois la valeur actuelle du compteur et la dernière entrée d'horloge vue (pour détecter les fronts montants).
      </p>
      <h2>
        CounterData
      </h2>
      <pre>package com.cburch.gray;

import com.cburch.logisim.data.BitWidth;
import com.cburch.logisim.data.Value;
import com.cburch.logisim.instance.InstanceData;
import com.cburch.logisim.instance.InstanceState;

/** Représente l'état d'un compteur. */
class CounterData implements InstanceData, Cloneable {
    
	/** Récupère l'état associé à ce compteur dans l'état du circuit,
     * générer l'etat si nécessaire.
     */
    public static CounterData get(InstanceState state, BitWidth width) {
        CounterData ret = (CounterData) state.getData();
        if(ret == null) {
		    /** S'il n'existe pas encore, nous le configurerons avec nos valeurs 
			  * par défaut et le mettrons à l'état de circuit afin qu'il puisse 
			  * être récupéré lors de futures propagations. */
            ret = new CounterData(null, Value.createKnown(width, 0));
            state.setData(ret);
        } else if(!ret.value.getBitWidth().equals(width)) {
            ret.value = ret.value.extendWidth(width.getWidth(), Value.FALSE);
        }
        return ret;
    }

    /** La dernière valeur d'entrée d'horloge observée. */
    private Value lastClock;
    
    /** La valeur courante émise par le compteur. */
    private Value value;

    /** Construit un état avec les valeurs données. */
    public CounterData(Value lastClock, Value value) {
        this.lastClock = lastClock;
        this.value = value;
    }

    /** Renvoie une copie de cet objet. */
    public Object clone() {
        /** Nous pouvons simplement utiliser ce que super.clone() renvoie : 
		  * Les seules variables d'instance sont les objets Value, qui sont 
		  * immuables, de sorte que nous ne nous soucions pas que la copie 
		  *	et le copié fassent référence aux mêmes objets Value. 
		  *	Si nous avions des variables d'instance mutables, nous aurions 
		  *	bien sûr besoin de les cloner. */
        try { return super.clone(); }
        catch(CloneNotSupportedException e) { return null; }
    }
    
    /** Met à jour la dernière horloge observée, en renvoyant true si elle 
	  * est déclenchée. */
    public boolean updateClock(Value value) {
        Value old = lastClock;
        lastClock = value;
        return old == Value.FALSE &amp;&amp; value == Value.TRUE;
    }
    
    /** Renvoie la valeur courante émise par le compteur.  */
    public Value getValue() {
        return value;
    }
    
    /** Met à jour la valeur courante émise par le compteur. */
    public void setValue(Value value) {
        this.value = value;
    }
}
</pre>
      <h2>
        SimpleCounter
      </h2>
      <pre>package com.cburch.gray;

import com.cburch.logisim.data.BitWidth;
import com.cburch.logisim.data.Bounds;
import com.cburch.logisim.data.Direction;
import com.cburch.logisim.instance.InstanceFactory;
import com.cburch.logisim.instance.InstancePainter;
import com.cburch.logisim.instance.InstanceState;
import com.cburch.logisim.instance.Port;
import com.cburch.logisim.util.GraphicsUtil;
import com.cburch.logisim.util.StringUtil;

/** Manufactures a simple counter that iterates over the 4-bit Gray Code. This
 * example illustrates how a component can maintain its own internal state. All
 * of the code relevant to state, though, appears in CounterData class. */
class SimpleGrayCounter extends InstanceFactory {
    private static final BitWidth BIT_WIDTH = BitWidth.create(4);
    
    // Again, notice how we don't have any instance variables related to an
    // individual instance's state. We can't put that here, because only one
    // SimpleGrayCounter object is ever created, and its job is to manage all
    // instances that appear in any circuits.
    
    public SimpleGrayCounter() {
        super("Gray Counter (Simple)");
        setOffsetBounds(Bounds.create(-30, -15, 30, 30));
        setPorts(new Port[] {
                new Port(-30, 0, Port.INPUT, 1),
                new Port(  0, 0, Port.OUTPUT, BIT_WIDTH.getWidth()),
        });
    }

    public void propagate(InstanceState state) {
        // Here I retrieve the state associated with this component via a helper
        // method. In this case, the state is in a CounterData object, which is
        // also where the helper method is defined. This helper method will end
        // up creating a CounterData object if one doesn't already exist.
        CounterData cur = CounterData.get(state, BIT_WIDTH);

        boolean trigger = cur.updateClock(state.getPort(0));
        if(trigger) cur.setValue(GrayIncrementer.nextGray(cur.getValue()));
        state.setPort(1, cur.getValue(), 9);
        
        // (You might be tempted to determine the counter's current value
        // via state.getPort(1). This is erroneous, though, because another
        // component may be pushing a value onto the same point, which would
        // "corrupt" the value found there. We really do need to store the
        // current value in the instance.)
    }

    public void paintInstance(InstancePainter painter) {
        painter.drawBounds();
        painter.drawClock(0, Direction.EAST); // draw a triangle on port 0
        painter.drawPort(1); // draw port 1 as just a dot
        
        // Display the current counter value centered within the rectangle.
        // However, if the context says not to show state (as when generating
        // printer output), then skip this.
        if(painter.getShowState()) {
            CounterData state = CounterData.get(painter, BIT_WIDTH);
            Bounds bds = painter.getBounds();
            GraphicsUtil.drawCenteredText(painter.getGraphics(),
                    StringUtil.toHexString(BIT_WIDTH.getWidth(), state.getValue().toIntValue()),
                    bds.getX() + bds.getWidth() / 2,
                    bds.getY() + bds.getHeight() / 2);
        }
    }
}
</pre>
      <p>
        <b>Suite&nbsp;:</b> <a href="counter.html">Gray Code Counter</a>.
      </p>
    </div>
  </body>
</html>
